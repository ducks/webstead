order = 14
what = "Create Follower model to track ActivityPub followers with their inbox URLs and acceptance status"
why = "Need to store follower data to know where to deliver Create activities when posts are published. Stores actor URI, inbox URLs (for delivery), and acceptance timestamp (to only deliver to confirmed followers). This is the foundation for announce-only federation."

how = """
1. Generate Follower model with required fields:
   - Run: rails g model Follower webstead:references actor_uri:string inbox_url:string shared_inbox_url:string accepted_at:datetime
   - This creates migration and model file

2. Add database constraints to migration:
   - Add null: false to webstead_id (every follower belongs to a webstead)
   - Add null: false to actor_uri (can't have follower without knowing who they are)
   - Add null: false to inbox_url (need inbox to deliver activities)
   - Add unique index on [webstead_id, actor_uri] (prevent duplicate follows)
   - Add index on webstead_id (for querying followers of a webstead)
   - Add index on accepted_at (to filter only accepted followers for delivery)
   - Migration file location: db/migrate/YYYYMMDDHHMMSS_create_followers.rb

3. Add validations to Follower model (app/models/follower.rb):
   - validates :actor_uri, presence: true, format: { with: URI::DEFAULT_PARSER.make_regexp(%w[http https]), message: "must be a valid HTTP(S) URL" }
   - validates :inbox_url, presence: true, format: { with: URI::DEFAULT_PARSER.make_regexp(%w[http https]) }
   - validates :shared_inbox_url, format: { with: URI::DEFAULT_PARSER.make_regexp(%w[http https]), allow_blank: true }
   - validates :actor_uri, uniqueness: { scope: :webstead_id, message: "is already following this webstead" }

4. Add tenant scoping to Follower model:
   - Include TenantScoped concern: include TenantScoped
   - This automatically scopes all queries to Current.webstead_id
   - Inherits default_scope and before_validation from concern

5. Add associations to Follower model:
   - belongs_to :webstead (already generated by rails g)
   - Add inverse association in Webstead model: has_many :followers, dependent: :destroy

6. Add helper scopes to Follower model:
   - scope :accepted, -> { where.not(accepted_at: nil) }
   - scope :pending, -> { where(accepted_at: nil) }
   - This allows filtering followers by acceptance status for delivery

7. Add helper methods to Follower model:
   - def accepted? = accepted_at.present?
   - def pending? = accepted_at.nil?
   - def accept! = update!(accepted_at: Time.current)
   - These provide clean interface for acceptance workflow

8. Run migration and verify schema:
   - Run: rails db:migrate
   - Check db/schema.rb for correct columns and indexes
   - Verify followers table has all constraints

9. Write comprehensive tests (spec/models/follower_spec.rb):
   - Test validations (presence, format, uniqueness)
   - Test tenant scoping (followers scoped to Current.webstead_id)
   - Test accepted/pending scopes
   - Test helper methods (accepted?, accept!)
   - Test associations (belongs_to webstead)
   - Test duplicate prevention (same actor can't follow twice)
   - Use fab! fixtures for test data

10. Manual testing in Rails console:
    - Create webstead: w = Webstead.create!(subdomain: "test", user_id: 1)
    - Set tenant: Current.webstead_id = w.id
    - Create follower: f = Follower.create!(actor_uri: "https://mastodon.social/users/test", inbox_url: "https://mastodon.social/users/test/inbox")
    - Test acceptance: f.accept!
    - Verify scoping: Follower.all only returns followers for Current.webstead_id
    - Test uniqueness: try creating duplicate follower (should fail)
"""

backup = """
If URI validation causes issues with real-world ActivityPub URIs:
1. Replace URI::DEFAULT_PARSER.make_regexp with simpler regex: /\Ahttps?:\/\/.+/
2. Or just validate presence and let ActivityPub protocol handle URI validation
3. Focus on ensuring URLs are non-empty strings, defer strict validation to HTTP signature verification

If tenant scoping conflicts with follower lookups:
1. Add class method for cross-tenant admin queries: def self.unscoped_find(id)
2. Keep default_scope for normal operations
3. Use unscoped only when explicitly needed for moderation/debugging
"""

[context]
files = [
  "app/models/webstead.rb",
  "app/models/concerns/tenant_scoped.rb",
  "db/schema.rb"
]
dependencies = [
  "rails",
  "postgresql"
]