order = 7
summary = "Create FederatedActor model to cache remote ActivityPub users"

what = "Build FederatedActor model to store cached data about remote ActivityPub users (Mastodon, etc.) who comment on posts"

why = "When displaying comments, we need to show display names and avatars for remote ActivityPub users. Rather than fetching actor data from remote servers on every page load (slow, unreliable), we cache the actor information locally and refresh periodically. This is standard practice for ActivityPub implementations."

how = """
1. Generate FederatedActor model and migration:
   rails g model FederatedActor actor_uri:string username:string display_name:string avatar_url:string last_fetched_at:datetime webstead:references

2. Edit migration to add constraints and indexes:
   - Add NOT NULL constraint on actor_uri and webstead_id
   - Add unique index on actor_uri (actor URIs are globally unique identifiers)
   - Add index on webstead_id for tenant filtering
   - Add index on last_fetched_at for refresh queries

3. Edit app/models/federated_actor.rb:
   - Add belongs_to :webstead association
   - Add has_many :comments association (foreign_key: :federated_actor_id)
   - Add validation: validates :actor_uri, presence: true, uniqueness: true
   - Add validation: validates :actor_uri, format: { with: URI::DEFAULT_PARSER.make_regexp(%w[http https]) }
   - Add method: def stale? - returns true if last_fetched_at is nil or older than 24 hours
   - Add method: def refresh_from_remote - fetches actor data from actor_uri and updates attributes
   - Add scope: scope :stale, -> { where('last_fetched_at IS NULL OR last_fetched_at < ?', 24.hours.ago) }

4. Add tenant scoping concern:
   include TenantScoped (if implemented in previous step)
   OR manually add: default_scope { where(webstead: Current.webstead) } and after_initialize callback

5. Create test file spec/models/federated_actor_spec.rb:
   - Test validations: actor_uri presence, uniqueness, format
   - Test associations: belongs_to webstead, has_many comments
   - Test stale? method: returns true for nil last_fetched_at, returns true for old timestamps, returns false for recent timestamps
   - Test scope :stale returns only actors with nil or old last_fetched_at
   - Test tenant scoping: creates actors in correct webstead context

6. Run migration:
   rails db:migrate

7. Run tests:
   bundle exec rspec spec/models/federated_actor_spec.rb

8. Verify in Rails console:
   rails c
   webstead = Webstead.first
   Current.webstead = webstead
   actor = FederatedActor.create!(actor_uri: 'https://mastodon.social/users/testuser', username: 'testuser')
   actor.stale? # should return true
   actor.update(last_fetched_at: Time.current)
   actor.stale? # should return false
"""

backup = """
If validating actor_uri format proves too strict (some ActivityPub implementations use non-standard URIs):
1. Remove format validation
2. Add custom validation method that checks for basic structure (starts with http/https, contains a hostname)
3. Add error handling in refresh_from_remote to gracefully handle malformed URIs

If tenant scoping via Current.webstead is not yet implemented:
1. Skip TenantScoped concern inclusion
2. Add manual belongs_to :webstead validation: validates :webstead, presence: true
3. Add index on webstead_id for filtering: add_index :federated_actors, :webstead_id
4. Filter manually in controllers/services when querying federated actors

If refresh_from_remote implementation is complex (requires HTTP fetching, JSON-LD parsing):
1. Leave method as stub for now: def refresh_from_remote; end
2. Implement in later step dedicated to ActivityPub fetching
3. Focus this step purely on data model and persistence layer
"""

[context]
files = [
    "app/models/webstead.rb",
    "app/models/comment.rb",
    "app/models/concerns/tenant_scoped.rb",
    "db/schema.rb"
]
dependencies = [
    "rails >= 8.0",
    "rspec-rails (for testing)"
]